[gd_scene load_steps=7 format=2]

[ext_resource path="res://images/gui/chat_bg/shape1.png" type="Texture" id=1]

[sub_resource type="Shader" id=1]
code = "shader_type canvas_item;

uniform sampler2D mask;
uniform vec4 color_dark : hint_color;
uniform vec4 color_light : hint_color;
uniform float phi;
uniform float speed = 1.0;
uniform float width = 1.0;

void fragment()
{
	vec2 uv = 4.0*mat2(vec2(cos(phi),sin(-phi)),vec2(sin(phi),cos(phi)))*(UV)*vec2(1.0,width)+vec2(0.0,speed*TIME);
	float w = texture(mask,uv).g;
	COLOR = color_dark*(1.0-w) + color_light*w;
//	COLOR = vec4(UV.x,UV.y,0.0,1.0);
}
"

[sub_resource type="ShaderMaterial" id=2]
shader = SubResource( 1 )
shader_param/color_dark = Color( 0.0941176, 0.25098, 0.501961, 1 )
shader_param/color_light = Color( 0.12549, 0.376471, 0.627451, 1 )
shader_param/phi = 0.785
shader_param/speed = 0.2
shader_param/width = 0.8
shader_param/mask = ExtResource( 1 )

[sub_resource type="GDScript" id=3]
script/source = "extends Control

const DISTANCE = 100.0
const RADIUS = 16.0
const LINE_WIDTH = 3.0
const COLORS = [
	Color(0.13,0.38,0.63),
	Color(0.5,0.25,0.5),
	Color(0.06,0.15,0.33)
]

onready var nodes := []
var connections := []

var delay := 0.5


func _draw():
	for k in nodes.size():
		for i in range(nodes[k].size()):
			for j in connections[k][i]:
				draw_line(nodes[k][i][0],nodes[k][j][0],COLORS[nodes[k][i][1]],LINE_WIDTH,true)
			draw_circle(nodes[k][i][0],RADIUS,COLORS[nodes[k][i][1]])
			draw_circle(nodes[k][i][0],RADIUS-3.0,Color(0.09,0.25,0.5))

func _process(delta):
	delay -= delta
	if delay<=0.0:
		if randf()<nodes.size()/30.0:
			remove_node()
		elif randf()<0.04:
			add_group()
		elif randf()<0.04:
			remove_group()
		elif randf()<0.25:
			add_connection()
		elif randf()<0.25:
			remove_connection()
		else:
			add_node()
		delay = rand_range(0.5,3.0)
	for k in range(nodes.size()):
		for i in range(nodes[k].size()):
#			var force := Vector2()
			var force = (rect_size/2.0-nodes[k][i][0])/3.0
#			for j in connections[k][i]:
#				var d = nodes[k][j][0]-nodes[k][i][0]
#				var length = max(d.length(),1.0)
#				force += d*(length-DISTANCE)/length
			for l in range(nodes.size()):
				for j in range(nodes[l].size()):
					var d = nodes[l][j][0]-nodes[k][i][0]
					var length = max(d.length(),1.0)
					if l==k && (j in connections[k][i]):
						force += d*(length-DISTANCE)/length
					else:
						force += d*min(length-2.0*DISTANCE,0.0)/length
			nodes[k][i][0] += delta*force
	update()

func add_node(group=randi()%nodes.size()):
#	var group := randi()%nodes.size()
	var parent = randi()%nodes[group].size()
	var pos = nodes[group][parent][0]+Vector2(rand_range(2.0,4.0),0.0).rotated(2.0*PI*randf())
	nodes[group].push_back([pos,0])
	connections[group].push_back([parent])
	for i in (randi()%3):
		var ID = randi()%nodes[group].size()
		connections[group][connections[group].size()-1].push_back(ID)
		if nodes[group][ID][1]==2:
			nodes[group][ID][1] = 0

func remove_node():
	var group := randi()%nodes.size()
	if nodes[group].size()<=1:
		return
	var ID = randi()%nodes[group].size()
	nodes[group].remove(ID)
	connections[group].remove(ID)
	for i in range(connections[group].size()-1,-1,-1):
		for j in range(connections[group][i].size()-1,-1,-1):
			if connections[group][i][j]>ID:
				connections[group][i][j] -= 1
			elif connections[group][i][j]==ID:
				connections[group][i].remove(j)
				if nodes[group][i][1]==1:
					nodes[group][i][1] = 0
				else:
					nodes[group][i][1] = 2

func add_group():
	var pos = OS.window_size*Vector2(randf(),randf())
	nodes.push_back([[pos,1]])
	connections.push_back([[]])
	for i in range(1+randi()%3):
		add_node(nodes.size()-1)

func remove_group():
	if nodes.size()<=1:
		return
	var group := randi()%nodes.size()
	nodes.remove(group)
	connections.remove(group)

func add_connection():
	var group := randi()%nodes.size()
	var ID = randi()%nodes[group].size()
	connections[group][ID].push_back(randi()%nodes[group].size())
	nodes[group][ID][1] = 1

func remove_connection():
	var group := randi()%nodes.size()
	var parent = randi()%nodes[group].size()
	if connections[group][parent].size()>0:
		connections[group][parent].erase(randi()%connections[group][parent].size())
		nodes[group][parent][1] = 2

func _ready():
	for i in range(3):
		add_group()
"

[sub_resource type="Animation" id=4]
length = 0.4
tracks/0/type = "value"
tracks/0/path = NodePath(".:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/keys = {
"times": PoolRealArray( 0, 0.4 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ Color( 1, 1, 1, 0 ), Color( 1, 1, 1, 1 ) ]
}

[sub_resource type="Animation" id=5]
length = 0.4
tracks/0/type = "value"
tracks/0/path = NodePath(".:modulate")
tracks/0/interp = 1
tracks/0/loop_wrap = true
tracks/0/imported = false
tracks/0/enabled = true
tracks/0/keys = {
"times": PoolRealArray( 0, 0.4 ),
"transitions": PoolRealArray( 1, 1 ),
"update": 0,
"values": [ Color( 1, 1, 1, 1 ), Color( 1, 1, 1, 0 ) ]
}
tracks/1/type = "method"
tracks/1/path = NodePath(".")
tracks/1/interp = 1
tracks/1/loop_wrap = true
tracks/1/imported = false
tracks/1/enabled = true
tracks/1/keys = {
"times": PoolRealArray( 0.4 ),
"transitions": PoolRealArray( 1 ),
"values": [ {
"args": [  ],
"method": "queue_free"
} ]
}

[node name="Panel" type="Panel"]
material = SubResource( 2 )
anchor_right = 1.0
anchor_bottom = 1.0
mouse_filter = 2

[node name="Nodes" type="Control" parent="."]
anchor_right = 1.0
anchor_bottom = 1.0
size_flags_horizontal = 3
size_flags_vertical = 3
script = SubResource( 3 )

[node name="AnimationPlayer" type="AnimationPlayer" parent="."]
autoplay = "fade_in"
anims/fade_in = SubResource( 4 )
anims/fade_out = SubResource( 5 )
